### 介绍

> 基本可用，如果没太高要求

![demo](demo.webp)

### 使用步骤

1. 在配置文件中[autobattle_config](../autobattle_config.yml)配置时间轴
2. 在战斗界面前或中开启脚本[battle.py](../battle.py)
3. 脚本运行期间输入命令字符然后回车可以操控当前脚本
   * `p` 暂停脚本 游戏界面点击菜单按钮，暂停当前执行
   * `r` 恢复脚本 游戏界面点击返回按钮，继续战斗流程
   * `s` 停止脚本 不会操作游戏界面
   * `c` 显示作业列表

### 配置文件

```yaml
listen_mouse_event: False # 设置为True时在鼠标点击后打印日志，押技能找适合的延后时间时使用，先手动点，然后看日志输出的延迟时间信息
use_ocr: False # 是否使用ocr识别时间
gpu: True # 是否开启GPU加速， 只有在使用ocr时才有效果
ub_check_threshold: 0.85 #sp条大于0.85确认为可释放UB状态
ub_check_timeout: 3 #如果UB未释放成功则在3秒内重复尝试
click_interval: 0.1 #每0.1秒尝试做一次点击操作 最好不要小于0.1
read_time_interval: 0.1 #每0.1秒读取一次战斗记录时间 最好不要小于0.1
job_list:
    # 操作列表：不同操作属性之间用空格隔开
    # 时间 位置 偏移
    # 时间：秒数，可以带小数即毫秒。同一秒的UB顺序控制通过调整列表的顺序即可，
    # 也就是说操作列表的顺序必须是时间顺序
    # 位置：位置是根据近战到远程顺序1-5号位
    # 偏移：给小于1的小数(也可以大于1比如同一秒有多个角色要释放技能会这个时间实际会持续很久)，正常到指定时间就会释放UB，如果希望延后(押技能)可以设置这个值
    # 例如：1:00 中时 二号位需要释放UB
    # 60 2
    "Do Nothing":
        - -1 -1
    "C5 MCW":
        - 69 1 0.6
        - 61 5 0.8
        - 61 3 4
        - 61 4 8
        - 59 2
        - 49 1 0.6
        - 47 5
        - 46 3
        - 46 4 5
        - 46 2 9
        - 40 1
        - 40 5 5
        - 40 2 10
        - 40 3 14
        - 40 4 20
        - 32 1
        - 31 5
        - 29 2
        - 29 3 4
        - 29 4 8
        - 26 1
        - 24 5
        - 15 3 0.8
        - 12 1
        - 11 5
        - 11 2 8
        - 11 4 12
        - 5 1
        - 5 5 3
        - 5 3 7
        - 5 2 10
        - 1 4
    "C5 普白琴姐":
        - 72 1
        - 61 4
        - 56 5
        - 56 1 0.8
        - 56 2 8
        - 56 3 11
        - 46 1 0.2
        - 44 4
        - 43 2
        - 41 3 0.2
        - 40 5 0.2
        - 40 1 0.8
        - 38 2 0.6
        - 37 4 0.6
        - 36 1
        - 29 5
        - 28 3
        - 27 2 0.7
        - 23 1 0.2
        - 20 4 0.6
        - 15 1
        - 14 3 0.6
        - 10 5 0.4
        - 10 2 0.8
        - 6 4
        - 4 2 0.6
        - 4 3 1
```

### 使用相关

* 由于游戏动画会影响sp值的读取，所以每个点击UB操作至少执行“一秒”，就算判断点击施放成功了也需要执行到下一秒
* UB超时时间注意不要超过同一个位置两次最短UB的时间间隔，如果发生重叠将不能按预期工作
* 为了获取比较准确的延迟时间，可以通过listen_mouse_event设置True之后观察日志打印的点击延迟时间，之后将该数据设置到配置文件中 （该功能依赖pynput, pip install pynput）
* 战斗界面建议不要开启二倍/四倍速和AUTO（目前按照0.1秒的时间间隔处理，大部分的轴在二倍速还是可以跑的）
* 使用ocr时，第一次启动需要下载OCR模型（启动脚本会自动下载）下载失败可以去[easy ocr](https://www.jaided.ai/easyocr/modelhub/)下载english_g2模型，然后解压放在用户目录的.EasyOCR/model下。

### 在其他分辨率或设备上运行

#### 不同的分辨率

目前该脚本所有都按照960*540分辨率硬编码，不过由于打轴实际依赖图片尺寸相关内容很少。还是比较容易改造的，可以按以下的步骤修改：

* 修改硬编码的坐标位置，包含sp条的位置、人物点击位置、以及时间区域
* 修改时间的模板图片，开启ocr识别之后通过ocr识别的结果生成90张对应秒数的图片 （可选，如果选择ocr方式）
* 修改点击菜单暂停页面返回键的图片（可选，这个只影响恢复时点击按钮重返战斗界面）
* 修改菜单的坐标位置 （可选，这个影响暂停操作能否暂停战斗界面）

#### 不同的设备/模拟器

针对非雷电模拟器的其他设备，可以考虑使用ADB方式使用，只要是Android设备都可以通过该方式。这种方式带来的问题是：

* 截图耗时长，目前会把设备的截图写入本地文件，再读取本地文件的图片
* 点击耗时长

### 调研

#### OCR模型调试

>  ocr识别时间戳

| 模型（cpu） | 耗时(s)   | 准确率(描述)                                                 |
| ----------- | --------- | ------------------------------------------------------------ |
| latin_g1    | 0.1-0.2   | 可以精准取得1:14的文字，存在特定的几个错误情况比较固定       |
| english_g2  | 0.05-0.06 | 无法得到正确结果，但是可以得到类似1.14这样的文字，存在比较多的输出结果类别 |

目前决定选择使用english_g2模型，对输出类型根据错误形式做修正。

安装CUDA后为0.01 - 0.02秒

#### 图片模板匹配

由于只需要识别90秒的时间，所以可以出90张模板图片用来匹配对应的时间

1. 使用图片hash定位

由于时间位置的背景并不是不透明的，所以这里会由于动画的影响导致同一秒内存在多个hash值

2. 使用图片相似性作为判断

这个方案是可行的，使用简单的余弦相似度计算就可以得到一个较理想的结果。该方案耗时在0.002-0.003之间

