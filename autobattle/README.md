### 介绍

> 基本可用，如果没太高要求

![demo](demo.webp)

### 使用步骤

1. 在配置文件中[autobattle_config](../autobattle_config.yml)配置时间轴
2. 在战斗界面前或中开启脚本[battle.py](../battle.py)
3. 脚本运行期间输入命令字符然后回车可以操控当前脚本
   * `p` 暂停脚本 游戏界面点击菜单按钮，暂停当前执行
   * `r` 恢复脚本 游戏界面点击返回按钮，继续战斗流程
   * `s` 停止脚本 不会操作游戏界面
   * `c` 显示作业列表

### 配置文件

```yaml
listen_mouse_event: False # 设置为True时在鼠标点击后打印日志，押技能找适合的延后时间时使用，先手动点，然后看日志输出的延迟时间信息
use_ocr: False # 是否使用ocr识别时间
gpu: True # 是否开启GPU加速， 只有在使用ocr时才有效果
ub_check_threshold: 0.85 #sp条大于0.85确认为可释放UB状态
ub_check_timeout: 3 #如果UB未释放成功则在3秒内重复尝试
click_interval: 0.1 #每0.1秒尝试做一次点击操作 最好不要小于0.1
read_time_interval: 0.1 #每0.1秒读取一次战斗记录时间 最好不要小于0.1
job_list:
    # 操作列表：不同操作属性之间用空格隔开
    # 时间 位置 偏移
    # 时间：秒数，可以带小数即毫秒。同一秒的UB顺序控制通过调整列表的顺序即可，
    # 也就是说操作列表的顺序必须是时间顺序
    # 位置：位置是根据近战到远程顺序1-5号位
    # 偏移：给小于1的小数，正常到指定时间就会释放UB，如果希望延后(押技能)可以设置这个值
    # 例如：1:00 中时 二号位需要释放UB
    # 60 2
    "Do Nothing":
        - -1 -1
    "C3 黄骑栞":
        - 79 5
        - 76 4
        - 75 1
        - 74 5
        - 69 1 0.2
        - 69 2 0.8
        - 67 5
        - 61 1
        - 60 2 0.2
        - 56 5 0.5
        - 55 1 0.7
        - 54 4 5
        - 52 1
        - 52 5 0.8
        - 51 2 0.2
        - 43 1
        - 42 5
        - 42 2 0.5
        - 41 3
        - 38 1
        - 34 4
        - 33 5
        - 33 2 0.2
        - 30 1
        - 27 5
        - 26 1
        - 23 2
        - 21 1 0.3
        - 21 3 0.8
        - 20 5
        - 17 4
        - 16 2
        - 14 1 0.1
        - 10 2
        - 9 1
        - 9 5 0.5
        - 3 1
        - 2 2
        - 1 5
        - 1 2
```

### 使用相关

* 由于游戏动画会影响sp值的读取，所以每个点击UB操作至少执行“一秒”，就算判断点击施放成功了也需要执行到下一秒
* UB超时时间注意不要超过同一个位置两次最短UB的时间间隔，如果发生重叠将不能按预期工作
* 为了获取比较准确的延迟时间，可以通过listen_mouse_event设置True之后观察日志打印的点击延迟时间，之后将改数据设置到配置文件中

### TODO List

- [x]  按照时间轴点击UB，支持一段时间内连续点击并智能判断是否成功释放UB
- [x] 运行中支持暂停、恢复。对应游戏内菜单操作
- [x] 支持设置偏移，用于处理押技能的问题
- [ ] 错误检测，指定时间段内UB未释放时 暂停游戏界面
- [ ] 错误检测，接近结束时判断伤害是否符合预期，不符合暂停游戏界面
- [ ] GUI

### 关注的问题

* 日志输出有点糟糕，操控和日志混在一起
* 战斗界面不能开启二倍/四倍速和AUTO（二倍/四倍会导致没有足够的时间校准战斗时间）
* 第一次启动时需要下载OCR模型，下载失败可以去[easy ocr](https://www.jaided.ai/easyocr/modelhub/)下载english_g2模型，然后解压放在用户目录的.EasyOCR/model下。

### 调研

#### OCR模型调试

>  ocr识别时间戳

| 模型（cpu） | 耗时(s)   | 准确率(描述)                                                 |
| ----------- | --------- | ------------------------------------------------------------ |
| latin_g1    | 0.1-0.2   | 可以精准取得1:14的文字，存在特定的几个错误情况比较固定       |
| english_g2  | 0.05-0.06 | 无法得到正确结果，但是可以得到类似1.14这样的文字，存在比较多的输出结果类别 |

目前决定选择使用english_g2模型，对输出类型根据错误形式做修正。

安装CUDA后为0.01 - 0.02秒

#### 图片模板匹配

由于只需要识别90秒的时间，所以可以出90张模板图片用来匹配对应的时间

1. 使用图片hash定位

由于时间位置的背景并不是不透明的，所以这里会由于动画的影响导致同一秒内存在多个hash值

2. 使用图片相似性作为判断

这个方案是可行的，使用简单的余弦相似度计算就可以得到一个较理想的结果。该方案耗时在0.002-0.003之间

